# Домашнее задание к занятию "6.6. Troubleshooting"

## Задача 1

### Напишите список операций, которые вы будете производить для остановки запроса пользователя:

Получу запросы со врменем выполнения больше 180с:

```
db.currentOp({"secs_running":{$gt:180}})
```

Пример результата:

```
{
    "locks": {
      "^": "w",
      "^local": "W",
      "^myDB": "W"
    },
    "ns": "myDB.bar",
    "op": "update",
    "opid": 1344808,
    "query": {},
    "secs_running": 53,
    "waitingForLock": false
  }
```

После чего можно прервать выполнение запроса:

```
db.killOp(1344808)
```

### Предложите вариант решения проблемы с долгими (зависающими) запросами в MongoDB:

Предпологается, что с железом нет проблем, т.е. проблема либо в настройках либо в не оптимизированных запросах.
Можно включить профилирование:


[db.setProfilingLevel(level, options)](https://docs.mongodb.com/manual/reference/method/db.setProfilingLevel/#mongodb-method-db.setProfilingLevel)

К примеру, для поиска медленных запросов:

```
db.setProfilingLevel(1,100)
U
Отключение звука (m)


Обращаясь к db.system.profile найти проблемные запросы. 
Далее уже разбираться в чем причина используя [explain()](https://docs.mongodb.com/manual/tutorial/analyze-query-plan/)

## Задача 2 

### Решение:

В соответствии с [документацией](https://redis.io/docs/manual/replication/) Redis начиная с версии 2.8 может быть сконфигурирован таким образом, что только при N подключенных репликах с задержкой менее M секунд запись доступна.

Вполне вероятно проблема может возникать при увеличении объема передоваемых данных, что влечет за собой нагрузку на "узкое" место в сети и как следствие отсутствие отклика за M секунд. Redis считает, что реплик менее N и блокирует запись.

## Задача 3 

### Решение:
 
Исходя из условия задачи, менялос только количество записей в таблицах. Т.е. можно не рассматривать варианты ошибок в запросах в виде не корректных связей (многие ко многим) между таблицами. Так как проблема возникает при выборке данных, то необходимо увеличить параметры отвечающие за timeout: connect_timeout, wait_timeout, interactive_timeout. Если это поможет, то проверить запросы. Определить по каким полям происходят связи между таблицами и какие поля используются в запросах, после проверить ниличие индексов. Возможно превышение размера буфера, необходимо проверить пераметр interactive_timeout.

## Задача 4

### Решение:

Проблема с доступной оперативной памятью Out Of Memory. Ядро операционной системы по средствам OOM killer пытается освободить память и завершает процесс.
Так как Postgres использует большой объем памяти на один процесс, то при вызове функции `select_bad_process()` с большой долей вероятности процесс Postgres будет определен как плохой и соответственно завершен будет первым.

Проверяем, что используемая ОС 64 разрядная, память действительно используется на 100% перед завершение процесса.
Если у нас почти безвыходная ситуация, нет возможности увеличить объем оперативной памяти, на жестких дисках отсутствет место для swap файла и/или swap раздел используется на 100% или дисковая подсистема не может быть использована для swap из-за низкой производительности или по другим причинам, а процесс Postgres должен работать, то можно изменить параметр ядра

```
oom_score_adj
```

для нашего процесса на большое отрицательное число к примеру -100. Изменить можно непосредственно во время исполнения через виртуальную файловую систему proc или задав значение в Service unit.

```
OOMScoreAdjust=-100
```

В данном случае мы уменьшаем вероятность того, что OOM-Killer завершит наш процесс, но это будет временным решением. 

Если действительно Postgres является причиной нехватки памяти, то проверю параметры работы с памятью:

`shared_buffers, work_mem и hash_mem_multiplier`  в случае возможности уменьшу значения.

Далее проверю параметры ядра. В соответствии со (статьей)[https://habr.com/ru/post/458860/?] оптимальная производительность Postgres зависит от правильно определенных параметров ОС. 

В проверю очередь проверю параметр [vm.overcommit_memory](https://www.postgresql.org/docs/current/kernel-resources.html#LINUX-MEMORY-OVERCOMMIT). 

В случае если у нас есть свободное дисковое пространство, то можно изменить параметры swap. Добавить еще один раздел или еще один файл swap. Проверю параметр vm.swappiness, по умолчанию должен быть 60.


