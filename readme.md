

# Домашнее задание к занятию "3.2. Работа в терминале, лекция 2"

## 1.

Проверим тип команды

``` bash
type -a cd
```

cd is a shell builtin

или

``` bash
type -t cd
```

builtin

это означает, что команда встроена в оболочку

А если выполним команду strace bash -c 'cd /', то увидем 

chdir("/")                              = 0

вызов процедуры chdir.

Мы можем написать свою программу с подобным функционалам, например на языке C используя процедуру chdir(),

далее скопилировать добавить путь к ней в PATH (или придется указывать полный путь до исполняемого файла) и использовать.

Команда type -t

нам сообщит, что наша команда: file, т.е. внешняя команда / исполняемый файл.


## 2. Для подсчета колчиства строк в файле содержащих исколмую строку правильно в данном случае будет использовать grep с параметром -c

``` bash
grep -c <some_string> <some_file>
```

## 3. При выводе списка процессов командой ps -aux можно видеть, что родителем явлется /sbin/init, но если выполним команду

``` bash
ls -l /sbin/init
```

увидем, что это ссылка на /lib/systemd/systemd

Также если выполним pstree -p, то увидем, что родителем является systemd.

## 4. Мы можем перенаправить вывод stderr используя следующий синтексис: 2>/dev/pts/x, где x - номер эмулятора терминала.

Пример: Находясь в эмуляторе терминале 0 выполним для перенаправления stderr в сессию 1 слудующюю команду:

``` bash
ls -la /empty 2>/dev/pts/1
```

В сессии эмулятора терминале 1 отобразиться:

ls: cannot access '/empty': No such file or directory

## 5. Можно. Используя операторы перенаправления ввода ">","<".

Пример:

``` bash
ls -la > file_stdin && grep drwx > another_file < file_stdin && cat another_file
```

- Направляем stdout команды ls -la в файл file_stdin.

- Если команда успшно выполнена (&&), то выполняем grep drwxс, передаем на stdin команды grep оператором "<" файл file_stdin и перенаправлением stdout оператором ">" в файл another_file результат выполнения grep.

- Если команда grep выполнена успешно (&&), то выводим содержимое файла another_file

## 6. Да.

Предположим мы находимся в псевдотерминале в графической оболочке
и редактируем данный файл в vim. Выполним команду tty и вставим результат в данный текст.
:r! tty
/dev/pts/6

Мы убедились, что находимся в псевдотерминале.
Передадим данные из нашего псевдотерминала в виртуальную консоль номер 3.

:! echo -e "\nHello tty3 \nHow are you?" > /dev/tty3

Перейдем в виртуальную консоль Ctr + Alt + F3 и убедимся, что сообщение поучено.
Бывают случаи когда tty3 далеко и у нас нет физической возможность перейти в него нажатием сочетания клавиш.

Обратимся к памяти виртуальной консоли выполнив команду:
:r! cat /dev/vcs3

Debian GNU/Linux 9 zh tty3
zh login:
Hello tty3
How are you?

## 7.
При выполнении команды bash 5>&1 создается новый процесс bash, новый файловый дискриптор 5 c перенаправлением в стандартный поток вывода stdout. Когда мы выполяем echo netology > /proc/$$/fd/5, то вывод команды направляется в 5, но так как 5 перенаправляется  в stdout, то на экране отобразится результат работы команды echo.
Но если выполнить команду ls -a /proc/$$/fd то увидем, что все файловые дискрипторы это сслыки на /dev/pts/x и соответсвтенно если мы находимся в виртуальном терминале, то с помощью команды ls -l /proc/$$/fd/ видно, что файловые дискрипторы по умолчанию ссылаются на /dev/tty/x, т.е. если бы мы выполнили bas 5>&2 и далее echo netology > /proc/$$/fd/5, результат был бы таким же.

	
## 8.
Изменить стандартные потоки местами через промежуточны дискриптор можно например следующим образом:

``` bash
echo -n "This is the stdout of the first command: "; ls -l /dev/null /empty 3>&1 1>&2 2>&3 | echo "This is the stderr of the first command: " $(</dev/stdin)
```

После выполнения команды, в случае отсутствия файла или директории /empty мы увидем следующий результат:
This is the stdout of the first command: crw-rw-rw- 1 root root 1, 3 ноя  4 21:49 /dev/null
This is the stderr of the first command:  ls: cannot access '/empty': No such file or directory


## 9. 
``` bash
cat /proc/$$/environ 
```

Выведит переменные окружения текущего интерпритатора.
Можно вывести переменные окружения оболочки командой env, а если хотим полного совпадения вывода, то уберем переносы строк:
``` bash
env | tr -d '\r\n'
```

## 10.
Описание данных файлов находиться на страницы  man относящейся к псевдо-файловой системе proc. 
 
/proc/PID/cmdline – Файл с атрибутами доступа только для чтения содержит командную строку процесса с идентификатором PID.
В случае зомби процессов данный файл будет пустым.

/proc/PID/exe - этот файл представляет собой символическую ссылку, содержащую фактический путь к выполняемой команде.



## 11.
Выполнив команду:
``` bash
grep 'sse' /proc/cpuinfo
```

Получаем результат:
flags           : fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush mmx fxsr sse sse2 ht syscall nx lm constant_tsc rep_good nopl cpuid tsc_known_freq pni ssse3 cx16 sse4_1 x2apic hypervisor lahf_lm pti

Наиболее старшая версия набора инструкций SSE поддерживаемая процессором: SSE4.1

## 12. 
Необходимо выполнить команду с флагом -t

``` bash
ssh -t localhost 'tty'
```

При выполнении команды на удаленном (локальном) компьютере выделяется tty даже если ssh не имел tty. 

## 13. 
Как говорится в man, reptyr зависит от системного вызова ptrace. Для Ubuntu  Maverick и выше это отключено, для включения необходимо выполнить:

``` bash
echo 0 |sudo tee /proc/sys/kernel/yama/ptrace_scope
```

Или отредактировать /etc/sysctl.d/10-ptrace.conf

Выполним команду:

``` bash
wget https://releases.ubuntu.com/20.04/ubuntu-20.04.3-desktop-amd64.iso
```

На втором терминале можно запустить screen или tmux или обойтись без них. Выполняем reptyr $(pgrep wget).

В man reptyr рекомендуется применение bg и disown для большей безопасности после переноса в старом терминале, если связь с поцессом осталась. 

## 14. 
sudo echo выполняется с правами root, но в файл запись происходит с правами текущего пользователя.
sudo tee записывает файл с правами root в этом можно убедиться выполнив ls -l.

Команда tee читает из stdin и записывает в stdout и файлы.

